/*
 * stm32l4xx_spi_driver.c
 *
 *  Created on: Aug 28, 2025
 *      Author: subha
 */

#include"stm32l4xx_spi_driver.h"

/*
 *	Peripheral clock setup
 */

void SPI_PeriClockControl(SPI_RegDef_t *pSPIx,uint8_t EnorDi){

	if(EnorDi == ENABLE ){

			if(pSPIx == SPI1 ){
				SPI1_PCLK_EN();

			}else if(pSPIx == SPI2 ){
				SPI2_PCLK_EN();

			}else if(pSPIx == SPI3 ){
				SPI3_PCLK_EN();

			}

		}else{

			if(pSPIx == SPI1 ){
				GPIOA_PCLK_DI();

			}else if(pSPIx == SPI2 ){
				GPIOB_PCLK_DI();

			}else if(pSPIx == SPI3 ){
				GPIOC_PCLK_DI();

			}
		}
}

void SPI_Init(SPI_Handle_t *pSPIHandle)
{

	uint32_t tempreg = 0;

	//1.Configure the device mode
	tempreg |= pSPIHandle->SPIConfig.SPI_DeviceMode << 2 ;

	//2.Configure the bus config

	if(pSPIHandle->SPIConfig.SPI_BusConfig == SPI_BUS_CONFIG_FD ){
		//bidi mode cleared
		tempreg &=~( 1<<15 );

	}else if(pSPIHandle->SPIConfig.SPI_BusConfig == SPI_BUS_CONFIG_HD){
		//budi mode is set
		tempreg |= (1<<15 );

	}else if(pSPIHandle->SPIConfig.SPI_BusConfig == SPI_BUS_CONFIG_SIMPLEX_RX){

		//BIDI mode should be cleared
		tempreg &=~(1<<15);
		//RXONLY bit must be set
		tempreg |=(1<<10);
	}

	//3.Configure the spi serial clock speed
	tempreg |= pSPIHandle->SPIConfig.SPI_SclkSpeed << 3 ;

	//4.Configure the DFF
	pSPIHandle->pSPIx->SPI_CR2 &= ~(0xF << SPI_CR2_DS);
	pSPIHandle->pSPIx->SPI_CR2 |= (pSPIHandle->SPIConfig.SPI_DFF << SPI_CR2_DS);

	//5.Configure the CPOL
	tempreg |= pSPIHandle->SPIConfig.SPI_CPOL << 1 ;

	//6.Configure the CPHA
	tempreg |= pSPIHandle->SPIConfig.SPI_CPHA << 0 ;

	pSPIHandle->pSPIx->SPI_CR1 = tempreg ;


}


/*********************************************************************
 * @fn      		  - SPI_DeInit
 *
 * @brief             - De-initializes (resets) the given SPI peripheral
 *
 * @param[in]         - pSPIx : Base address of the SPI peripheral (SPI1, SPI2, SPI3)
 *
 * @return            - None
 *
 * @Note              - Uses peripheral reset macros defined in MCU-specific header
 *********************************************************************/
void SPI_DeInit(SPI_RegDef_t *pSPIx)
{
    if(pSPIx == SPI1)
    {
        SPI1_REG_RESET();
    }
    else if(pSPIx == SPI2)
    {
        SPI2_REG_RESET();
    }
    else if(pSPIx == SPI3)
    {
        SPI3_REG_RESET();
    }
}

uint8_t SPI_GetFlagStatus(SPI_RegDef_t *pSPIx  , uint32_t FlagName ){

	if(pSPIx->SPI_SR & FlagName ){
		return FLAG_SET ;
	}

	return FLAG_RESET ;
}

/*********************************************************************
 * @fn      		  - SPI_SendData
 *
 * @brief             - Sends data over SPI (blocking mode, polling TXE flag)
 *
 * @param[in]  pSPIx  - Base address of the SPI peripheral (SPI1, SPI2, ...)
 * @param[in]  pTxBuffer - Pointer to the transmit buffer containing data to be sent
 * @param[in]  Len    - Length of data (in bytes) to be sent
 *
 * @return            - None
 *
 * @Note              - This function waits until TXE flag is set before writing data
 *                      - If DFF = 1 (16-bit mode), data is sent in 2-byte chunks
 *                      - If DFF = 0 (8-bit mode), data is sent in 1-byte chunks
 *                      - Blocking call: CPU will be busy until all bytes are transmitted
 *********************************************************************/


void SPI_SendData(SPI_RegDef_t *pSPIx , uint8_t *pTxBuffer , uint32_t Len ){

	while(Len > 0 ){
		//wait untill TXE is set
		while(SPI_GetFlagStatus(pSPIx , SPI_TXE_FLAG ) == FLAG_RESET );

		//2. Check the DFF bit

		if(pSPIx->SPI_CR1 & (1<<SPI_CR1_DFF )){

			//16 bit DFF
			//1.load the data in to the DR

			pSPIx->SPI_DR = *((uint16_t *)pTxBuffer);
			Len--;
			Len--;
			(uint16_t *)pTxBuffer++;
		}else{
			//8 bit data

			pSPIx->SPI_DR = *(pTxBuffer);
			Len--;
			pTxBuffer++ ;
		}
	}

}


/*
 * SPI PeripheralControl
 *
 */

void SPI_PeripheralControl(SPI_RegDef_t *pSPIx , uint8_t EnOrDi){

	if(EnOrDi == ENABLE ){

		pSPIx->SPI_CR1 |= (1<< SPI_CR1_SPE);

	}else{

		pSPIx->SPI_CR1 &=~(1<<SPI_CR1_SPE);
	}

}
